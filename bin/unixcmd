#!/usr/bin/ruby19

require 'gtk2'
require 'vte'
require 'open3'
require 'pathname'

[ 'panel', 'version', 'config' ].each do |lib|
    require "unixcmd/#{lib}"
end

class CmdWnd < Gtk::Window
    @vbox
    @btnpanel
    @panes
    @left
    @right
    @terminal
    @curpanel

    def left() @left end
    def right() @right end

    def initialize
        super

        set_title APP_NAME + ' ' + APP_VERSION

        set_border_width 5

        @vbox = Gtk::VPaned.new
        @panes = Gtk::HPaned.new
        @left = CmdPanelWidget.new
        @right = CmdPanelWidget.new
        @terminal = Vte::Terminal.new

        @terminal.height_request = 10
        @terminal.fork_command({:argv => ['bash']})
        @terminal.set_font 'Monospace'
        @terminal.scrollback_lines = 99999 

        # add hotkey to switch to/from console (Ctrl-C)
        # inactivate console when execute commands in bash
        #@terminal.sensitive = false

        @panes.pack1 @left, true, true
        @panes.pack2 @right, true, true

        @vbox.pack1 @panes, true, true
        @vbox.pack2 @terminal, true, true

        add @vbox

        @left.signal_connect('dir-changed') { dir_changed @left } 
        @right.signal_connect('dir-changed') { dir_changed @right } 
        signal_connect('destroy') { destroy }
        signal_connect('set-focus') { |s, w| focus_changed w }

        self.focus_chain = [@left, @right]

        set_default_size 1024, 768 
        show_all

        sleep 1
        @terminal.feed_child 'bind -x \'"\033d":". /tmp/tmp.sh"\'' + "\n"
        cmd "cd #{curpanel.path}\n"
        #cmd "export PROMPT_COMMAND='echo a'"
        #@terminal.feed_child "clear\n"
        @terminal.signal_connect('child-exited') { destroy }

        @curpanel = @left
    end

    def curpanel
      @curpanel
    end

    def otherpanel
        return @left if @curpanel == @right
        @right
    end

    def focus_changed widget
      return unless widget

      oldcur = curpanel

      @curpanel = @left if widget.inside? @left
      @curpanel = @right if widget.inside? @right

      cmd "cd #{curpanel.path}" unless oldcur == curpanel
    end

    def dir_changed pane
      cmd "cd #{pane.path}"
    end

    def selected_file
        curpanel.path + curpanel.selection[0]
    end

    def destroy
        Gtk.main_quit
    end

    def cmd data
      IO.write '/tmp/tmp.sh', data + "\n"
      @terminal.feed_child "\033d\n"
    end
end


GLib::Thread.init
Gdk::Threads.init
Gdk::Threads.enter

Gtk::AccelMap.add_entry '<unixcmd>/panel/reload',   Gdk::Keyval::GDK_F2, nil 

Gtk::AccelMap.add_entry '<unixcmd>/file/view',   Gdk::Keyval::GDK_F3, nil 
Gtk::AccelMap.add_entry '<unixcmd>/file/edit',   Gdk::Keyval::GDK_F4, nil 
Gtk::AccelMap.add_entry '<unixcmd>/file/copy',   Gdk::Keyval::GDK_F5, nil 
Gtk::AccelMap.add_entry '<unixcmd>/file/move',   Gdk::Keyval::GDK_F6, nil 
Gtk::AccelMap.add_entry '<unixcmd>/file/mkdir',  Gdk::Keyval::GDK_F7, nil 
Gtk::AccelMap.add_entry '<unixcmd>/file/remove', Gdk::Keyval::GDK_F8, Gdk::Window::SHIFT_MASK 

Gtk::AccelMap.add_entry '<unixcmd>/test/print_selection', Gdk::Keyval::GDK_F11, nil 

Gtk::AccelMap.add_entry '<unixcmd>/file/info', Gdk::Keyval::GDK_Return, Gdk::Window::MOD1_MASK

Gtk::AccelMap.add_entry '<unixcmd>/app/quit', Gdk::Keyval::GDK_F4, Gdk::Window::MOD1_MASK


require 'unixcmd/cmd'


$wnd = CmdWnd.new
$wnd.add_accel_group $accels

Gtk.main

Gdk::Threads.leave

# vim: sw=2 sts=2 ts=8:

